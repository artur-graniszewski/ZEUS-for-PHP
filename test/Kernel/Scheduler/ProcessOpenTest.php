<?php

namespace ZeusTest\Kernel\Scheduler;

use PHPUnit\Framework\TestCase;
use ReflectionClass;
use Zend\ServiceManager\ServiceManager;
use Zeus\IO\Stream\FileStream;
use Zeus\Kernel\Scheduler\MultiProcessingModule\Factory\MultiProcessingModuleFactory;
use Zeus\Kernel\Scheduler\MultiProcessingModule\ModuleDecorator;
use Zeus\Kernel\Scheduler\MultiProcessingModule\MultiProcessingModuleCapabilities;
use Zeus\Kernel\Scheduler\MultiProcessingModule\ProcessOpen;
use Zeus\Kernel\Scheduler\Status\WorkerState;
use Zeus\Kernel\Scheduler\WorkerEvent;
use Zeus\Kernel\Scheduler;
use Zeus\Kernel\Scheduler\SchedulerEvent;
use Zeus\Kernel\SchedulerInterface;
use ZeusTest\Helpers\PcntlBridgeMock;
use ZeusTest\Helpers\ProcessOpenBridgeMock;
use ZeusTest\Helpers\ZeusFactories;

/**
 * Class ProcessOpenTest
 * @package ZeusTest\Kernel\Scheduler
 * @preserveGlobalState disabled
 */
class ProcessOpenTest extends TestCase
{
    use ZeusFactories;

    /**
     * @param SchedulerInterface $scheduler
     * @return SchedulerEvent
     */
    protected function getEvent(SchedulerInterface $scheduler)
    {
        $rc = new ReflectionClass(Scheduler::class);
        $property = $rc->getProperty('event');
        $property->setAccessible(true);

        return $property->getValue($scheduler);
    }

    /**
     * @param mixed[] $log
     * @param $methodName
     * @return int
     */
    protected function countMethodInExecutionLog($log, $methodName)
    {
        $found = 0;
        foreach ($log as $entry) {
            if (preg_match('~' . $methodName . '$~', $entry[0])) {
                $found++;
            }
        }

        return $found;
    }

    private function getCustomServiceManager() : ServiceManager
    {
        $sm = $this->getServiceManager([
            'zeus_process_manager' => [
                'schedulers' => [
                    'test_scheduler_1' => [
                        'multiprocessing_module' => ProcessOpen::class,
                    ]
                ]
            ]
        ]);
        $sm->setFactory(ProcessOpen::class, MultiProcessingModuleFactory::class);
        return $sm;
    }

    public function testProcessOpenFactory()
    {
        if (defined("HHVM_VERSION")) {
            $this->markTestSkipped("HHVM does not support pipes as IPC transport");
        }

        $self = $_SERVER['PHP_SELF'];
        $_SERVER['PHP_SELF'] = __DIR__ . '/ProcessOpenExec.php';

        if (!ProcessOpen::isSupported($message)) {
            $this->markTestSkipped($message);
        }

        $bridge = new ProcessOpen\ProcessOpenBridge();
        $stdOutName = tempnam(sys_get_temp_dir(), "zeus-test");
        $stdErrName = tempnam(sys_get_temp_dir(), "zeus-test");
        $stdOut = @fopen($stdOutName, "r");
        $stdErr = @fopen($stdErrName, "r");

        $bridge->setStdErr($stdErrName);
        $bridge->setStdOut($stdOutName);
        ProcessOpen::setProcessBridge($bridge);
        $sm = $this->getCustomServiceManager();
        $scheduler = $this->getScheduler(1, null, $sm);

        $events = $scheduler->getEventManager();
        $events->attach(WorkerEvent::EVENT_EXIT, function(WorkerEvent $e) {
            $e->stopPropagation(true);
        }, WorkerEvent::PRIORITY_FINALIZE + 1);
        $this->simulateWorkerInit($events);


        $eventLaunched = false;
        $events->attach(SchedulerEvent::EVENT_START, function(SchedulerEvent $event) use (&$eventLaunched) {
            $event->stopPropagation(true);
        }, SchedulerEvent::PRIORITY_FINALIZE + 1);

        $amount = 0;
        $events->attach(WorkerEvent::EVENT_CREATE, function(WorkerEvent $event) use (&$eventLaunched, &$amount) {
            $amount++;
        }, SchedulerEvent::PRIORITY_INITIALIZE + 1);

        $this->simulateWorkerInit($events);

        $events->attach(SchedulerEvent::EVENT_STOP, function(SchedulerEvent $event) use (&$eventLaunched) {
            $eventLaunched = true;
            $event->stopPropagation(true);
        }, SchedulerEvent::PRIORITY_FINALIZE + 1);

        $scheduler->getEventManager()->attach(WorkerEvent::EVENT_LOOP, function(WorkerEvent $event) {
            $event->getWorker()->setCode(WorkerState::EXITING);
        }, WorkerEvent::PRIORITY_FINALIZE + 1);

        $event = $scheduler->getWorkerEvent();
        $event->setName(WorkerEvent::EVENT_INIT);
        $event->setParam(SchedulerInterface::WORKER_INIT, true);
        $event->setParam(SchedulerInterface::WORKER_SERVER, true);
        $event->setParam(ModuleDecorator::ZEUS_IPC_ADDRESS_PARAM, "tcp://127.0.0.1:0");
        $events->triggerEvent($event);

        $scheduler->start(false);
        $em = $scheduler->getEventManager();
        $event = new SchedulerEvent();
        $event->setScheduler($scheduler);
        $event->setTarget($scheduler);
        $event->setName(SchedulerEvent::EVENT_LOOP);
        $event->setParam('uid', 123456);
        // first event may register workers
        $em->triggerEvent($event);

        // the second one will probably check their status
        $time = time();
        $em->triggerEvent($event);

        $stdOutStream = new FileStream($stdOut);
        $stdErrStream = new FileStream($stdErr);
        do {
            $stdOutStream->setPosition(0);
            $buffer = $stdOutStream->read();
            $em->triggerEvent($event);
        } while ($time > time() - 2 && substr_count($buffer, "\n") <  3);
        $_SERVER['PHP_SELF'] = $self;

        $jsonLines = explode("\n", $buffer);
        $jsonLines = array_filter($jsonLines);

        $workers = [];
        $workerIds = [];
        foreach ($jsonLines as $json) {
            $worker = json_decode($json);
            $workers[] = $worker;
            $workerIds[] = $worker->pid;
        }

        $stdErrStream->setPosition(0);
        unlink($stdErrName);
        unlink($stdOutName);

        $errorLines = array_filter(explode("\n", $stdErrStream->read()));

        foreach ($errorLines as $errorLine) {
            $this->assertStringStartsWith("ERROR LINE", $errorLine);
        }
        $this->assertEquals(3, count($jsonLines), "Two worker outputs should be returned by ProcessOpen MPM");
        $this->assertEquals(6, count($errorLines), "Four worker error lines should be returned by ProcessOpen MPM");
        $this->assertEquals(3, count(array_unique($workerIds)), "Each worker should have an unique ID");
        $this->assertTrue($eventLaunched, 'EVENT_SCHEDULER_STOP should have been triggered by ProcessOpen');
    }

    public function testDetectionIfProcessOpenIsSupportedOrNot()
    {
        $bridge = new ProcessOpenBridgeMock();
        ProcessOpen::setProcessBridge($bridge);

        $status = [];

        foreach ([true, false] as $isSupported) {
            $bridge->setIsSupported($isSupported);

            $status[$isSupported] = '';

            $this->assertEquals($isSupported, ProcessOpen::isSupported($status[$isSupported]), ('PCNTL should be ' . $isSupported ? 'enabled' : 'disabled'));
        }

        if (defined("HHVM_VERSION")) {
            $this->assertEquals("HHVM does not support pipes as IPC transport", $status[false], 'Error message should be returned if MPM driver is not supported');
        } else {
            $this->assertEquals("proc_open() and proc_get_status() are required by ProcessOpen but disabled in PHP", $status[false], 'Error message should be returned if MPM driver is not supported');
        }
        $this->assertEquals("", $status[true], 'No error message should be returned if MPM driver is supported');
    }

    public function testProcessTermination()
    {
        $bridge = new ProcessOpen\ProcessOpenBridge();
        ProcessOpen::setProcessBridge($bridge);
        if (defined("HHVM_VERSION")) {
            $this->markTestSkipped("HHVM does not support pipes as IPC transport");
        }

        if (!defined("SIGKILL")) {
            $this->markTestSkipped("Undefined SIGKILL constant");
        }

        if (!ProcessOpen::isSupported($message)) {
            $this->markTestSkipped($message);
        }

        $bridge = new ProcessOpen\ProcessOpenBridge();
        $stdOutName = tempnam(sys_get_temp_dir(), "zeus-test");
        $stdErrName = tempnam(sys_get_temp_dir(), "zeus-test");
        $stdOut = @fopen($stdOutName, "r");
        $stdErr = @fopen($stdErrName, "r");

        $bridge->setStdErr($stdErrName);
        $bridge->setStdOut($stdOutName);
        ProcessOpen::setProcessBridge($bridge);

        $pcntlMock = new PcntlBridgeMock();
        ProcessOpen::setPcntlBridge($pcntlMock);
        $sm = $this->getCustomServiceManager();
        $scheduler = $this->getScheduler(1, null, $sm);
        $em = $scheduler->getEventManager();
        $em->attach(WorkerEvent::EVENT_EXIT, function(WorkerEvent $e) {
            $e->stopPropagation(true);
        }, WorkerEvent::PRIORITY_FINALIZE + 1);

        $em->attach('*', function(SchedulerEvent $e) {

        }, WorkerEvent::PRIORITY_FINALIZE + 1);
        $this->simulateWorkerInit($em);

        $event = $scheduler->getSchedulerEvent();
        $event->setName(SchedulerEvent::EVENT_START);
        $event->setParam('uid', 123456);
        $em->triggerEvent($event);

        $event = new WorkerEvent();
        $event->setTarget($scheduler);
        $event->setName(WorkerEvent::EVENT_TERMINATE);
        $event->setParam('uid', 123456);
        $event->setParam('soft', false);
        $em->triggerEvent($event);

        $logArray = $pcntlMock->getExecutionLog();
        $this->assertEquals(1, $this->countMethodInExecutionLog($logArray, 'posixKill'), 'Kill signal should be sent');
        $this->assertEquals(123456, $logArray[18][1][0], 'Kill signal should be sent to a certain process');
        $this->assertEquals(SIGKILL, $logArray[18][1][1], 'Correct type of kill signal should be sent to a certain process');
        $this->assertEquals(WorkerEvent::EVENT_TERMINATE, $event->getName());
        $pcntlMock->setExecutionLog([]);
    }

    public function testPosixCapabilities()
    {
        $posixProcess = new ProcessOpen();
        $capabilities = $posixProcess::getCapabilities();

        $this->assertInstanceOf(MultiProcessingModuleCapabilities::class, $capabilities);
        $this->assertEquals(MultiProcessingModuleCapabilities::ISOLATION_PROCESS, $capabilities->getIsolationLevel());
    }
}