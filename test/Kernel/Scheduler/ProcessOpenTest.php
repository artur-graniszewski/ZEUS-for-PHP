<?php

namespace ZeusTest\Kernel\Scheduler;

use PHPUnit_Framework_TestCase;
use Zend\EventManager\EventManager;
use Zend\EventManager\SharedEventManager;
use Zend\Log\Logger;
use Zend\Log\Writer\Noop;
use Zeus\Kernel\Scheduler\MultiProcessingModule\Factory\MultiProcessingModuleFactory;
use Zeus\Kernel\Scheduler\MultiProcessingModule\ModuleWrapper;
use Zeus\Kernel\Scheduler\MultiProcessingModule\MultiProcessingModuleCapabilities;
use Zeus\Kernel\Scheduler\MultiProcessingModule\ProcessOpen;
use Zeus\Kernel\Scheduler\WorkerEvent;
use Zeus\Kernel\Scheduler;
use Zeus\Kernel\Scheduler\SchedulerEvent;
use ZeusTest\Helpers\PcntlMockBridge;
use ZeusTest\Helpers\ZeusFactories;

/**
 * Class ProcessOpenTest
 * @package ZeusTest\Kernel\Scheduler
 * @preserveGlobalState
 * @runInSeparateProcess
 * @runTestsInSeparateProcesses 
 */
class ProcessOpenTest extends PHPUnit_Framework_TestCase
{
    use ZeusFactories;

    /**
     * @param Scheduler $scheduler
     * @return SchedulerEvent
     */
    protected function getEvent(Scheduler $scheduler)
    {
        $rc = new \ReflectionClass(Scheduler::class);
        $property = $rc->getProperty('event');
        $property->setAccessible(true);

        return $property->getValue($scheduler);
    }

    /**
     * @param mixed[] $log
     * @param $methodName
     * @return int
     */
    protected function countMethodInExecutionLog($log, $methodName)
    {
        $found = 0;
        foreach ($log as $entry) {
            if (preg_match('~' . $methodName . '$~', $entry[0])) {
                $found++;
            }
        }

        return $found;
    }

    private function getMpm(Scheduler $scheduler) : ModuleWrapper
    {
        $sm = $this->getServiceManager();
        $sm->setFactory(ProcessOpen::class, MultiProcessingModuleFactory::class);
        $logger = new Logger();
        $logger->addWriter(new Noop());

        $service = $sm->build(ProcessOpen::class, [
            'scheduler_event' => new SchedulerEvent(),
            'worker_event' => new WorkerEvent(),
            'logger_adapter' => $logger,
            'event_manager' => $scheduler->getEventManager()
        ]);

        $this->assertInstanceOf(ProcessOpen::class, $service);

        $service = new ModuleWrapper($service);
        $service->setLogger($scheduler->getLogger());
        $worker = new Scheduler\Worker();
        $worker->setConfig(new Scheduler\Config([]));
        $workerEvent = new WorkerEvent();
        $workerEvent->setWorker($worker);
        $workerEvent->setTarget($worker);
        $service->setWorkerEvent($workerEvent);
        $schedulerEvent = new SchedulerEvent();
        $schedulerEvent->setScheduler($scheduler);
        $service->setSchedulerEvent($schedulerEvent);
        $service->setEventManager($scheduler->getEventManager());
        return $service;
    }

    public function testProcessOpenFactory()
    {
        $sm = $this->getServiceManager();
        $scheduler = $this->getScheduler(1);

        $event = new SchedulerEvent();
        $event->setScheduler($scheduler);
        $sm->setFactory(ProcessOpen::class, MultiProcessingModuleFactory::class);
        $service = $this->getMpm($scheduler);

        $eventLaunched = false;
        $scheduler->getEventManager()->attach(SchedulerEvent::EVENT_START, function(SchedulerEvent $event) use (&$eventLaunched) {
            $event->stopPropagation(true);
        }, SchedulerEvent::PRIORITY_FINALIZE + 1);

        $scheduler->getEventManager()->attach(WorkerEvent::EVENT_INIT, function(WorkerEvent $event) use (&$eventLaunched) {
            $event->stopPropagation(true);
        }, SchedulerEvent::PRIORITY_INITIALIZE + 1);

        $scheduler->getEventManager()->attach(SchedulerEvent::EVENT_STOP, function(SchedulerEvent $event) use (&$eventLaunched) {
            $eventLaunched = true;
            $event->stopPropagation(true);
        }, SchedulerEvent::PRIORITY_FINALIZE + 1);

        $self = $_SERVER['PHP_SELF'];
        $_SERVER['PHP_SELF'] = __DIR__ . '/ProcessOpenExec.php';
        $scheduler->start(false);
        $em = $scheduler->getEventManager();
        $event = new SchedulerEvent();
        $event->setScheduler($scheduler);
        $event->setTarget($scheduler);
        $event->setName(SchedulerEvent::EVENT_LOOP);
        $event->setParam('uid', 123456);
        $em->triggerEvent($event);
        $_SERVER['PHP_SELF'] = $self;
        $this->assertTrue($eventLaunched, 'EVENT_SCHEDULER_STOP should have been triggered by ProcessOpen');
    }

    public function testProcessTermination()
    {
        if (!defined("SIGKILL")) {
            $this->markTestSkipped("Undefined SIGKILL constant");
        }

        $scheduler = $this->getScheduler(1);
        $em = new EventManager(new SharedEventManager());
        $posixProcess = $this->getMpm($scheduler);
        $posixProcess->setEventManager($em);

        $pcntlMock = new PcntlMockBridge();
        ProcessOpen::setPcntlBridge($pcntlMock);
        $event = new SchedulerEvent();
        $event->setScheduler($scheduler);
        $event->setTarget($scheduler);
        $event->setName(SchedulerEvent::EVENT_START);
        $event->setParam('uid', 123456);
        $em->triggerEvent($event);

        $event = new WorkerEvent();
        $event->setScheduler($scheduler);
        $event->setTarget($scheduler);
        $event->setName(WorkerEvent::EVENT_TERMINATE);
        $event->setParam('uid', 123456);
        $event->setParam('soft', false);
        $em->triggerEvent($event);

        $logArray = $pcntlMock->getExecutionLog();
        $this->assertEquals(1, $this->countMethodInExecutionLog($logArray, 'posixKill'), 'Kill signal should be sent');
        $this->assertEquals(123456, $logArray[1][1][0], 'Kill signal should be sent to a certain process');
        $this->assertEquals(SIGKILL, $logArray[1][1][1], 'Correct type of kill signal should be sent to a certain process');
        $this->assertEquals(WorkerEvent::EVENT_TERMINATE, $event->getName());
        $pcntlMock->setExecutionLog([]);
    }

    public function testDetectionOfProcessTermination()
    {
        $this->markTestIncomplete();
        $worker = new Scheduler\Worker();
        $scheduler = $this->getScheduler(1);
        $em = new EventManager(new SharedEventManager());
        $em->attach(WorkerEvent::EVENT_TERMINATED, function($event) use (&$triggeredEvent) {
            $triggeredEvent = $event;
        });

        $pcntlMock = new PcntlMockBridge();
        $pcntlMock->setPcntlWaitPids([98765]);
        $pcntlMock->setForkResult(98765);

        ProcessOpen::setPcntlBridge($pcntlMock);
        $schedulerEvent = new SchedulerEvent();
        $schedulerEvent->setScheduler($scheduler);
        $workerEvent = new WorkerEvent();
        $workerEvent->setWorker($worker);
        $posixProcess = $this->getMpm($scheduler);
        $posixProcess->setSchedulerEvent($schedulerEvent);
        $posixProcess->setWorkerEvent($workerEvent);
        $posixProcess->setEventManager($em);

        $workerEvent->setName(WorkerEvent::EVENT_CREATE);
        $em->triggerEvent($workerEvent);

        $schedulerEvent->setName(SchedulerEvent::EVENT_LOOP);
        $em->triggerEvent($schedulerEvent);

        $this->assertNotNull($triggeredEvent);
        $logArray = $pcntlMock->getExecutionLog();
        $this->assertEquals(2, $this->countMethodInExecutionLog($logArray, 'pcntlWait'), 'Wait for signal should be performed');
        $this->assertEquals(98765, $triggeredEvent->getWorker()->getUid(), 'Correct process UID should be returned on its termination');
    }

    public function testDetectionIfPcntlIsSupportedOrNot()
    {
        $this->markTestIncomplete();
        $pcntlMock = new PcntlMockBridge();
        ProcessOpen::setPcntlBridge($pcntlMock);

        $status = [];

        foreach ([true, false] as $isSupported) {
            $pcntlMock->setIsSupported($isSupported);

            $status[$isSupported] = '';

            $this->assertEquals($isSupported, ProcessOpen::isSupported($status[$isSupported]), ('PCNTL should be ' . $isSupported ? 'enabled' : 'disabled'));
        }

        $this->assertEquals("PCNTL extension is required by ProcessOpen but disabled in PHP", $status[false], 'Error message should be returned if MPM driver is not supported');
        $this->assertEquals("", $status[true], 'No error message should be returned if MPM driver is not supported');
    }

    public function testPosixCapabilities()
    {
        $posixProcess = new ProcessOpen();
        $capabilities = $posixProcess::getCapabilities();

        $this->assertInstanceOf(MultiProcessingModuleCapabilities::class, $capabilities);
        $this->assertEquals(MultiProcessingModuleCapabilities::ISOLATION_PROCESS, $capabilities->getIsolationLevel());
    }
}